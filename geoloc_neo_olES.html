<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>POC Geoloc - OL + ES</title>
  <link rel="stylesheet" href="geoloc_neo_ol_lh.css">
  <link rel="stylesheet" href="openlayers/ol.css" type="text/css">

</head>
<body>

  <div id="map"></div>

  <div id="idDiv" >
    <p>Identifiant radio</p>
    <form id="myForm" onsubmit="return false;">
      <div id="idInputDiv"><input id="idInput" type="text" name="idRadio"></div>
      <a href="#"><img src="images/bicycle.png" onclick="login('b_')" alt="vélo" class="imgButton"></a>
      <a href="#"><img src="images/bike.png" onclick="login('m_')" alt="moto" class="imgButton"></a>
      <a href="#"><img src="images/car.png" onclick="login('c_')" alt="voiture" class="imgButton"></a><br>
      <a href="#"><img src="images/policeman.png" onclick="login('p_')" alt="piéton" class="imgButton"></a>
      <a href="#"><img src="images/office.png" onclick="login('o_')" alt="bureau" class="imgButton"></a>
      <a href="#"><img src="images/boat.png" onclick="login('f_')" alt="bateau" class="imgButton"></a>
    </form>
  </div>

  <div id="error" class="popup" style="display:none"></div>
  <div id="notification" class="popup" style="display:none"></div>

  <div id="centerDiv">
    <div id="centerUI">
      <div id="centerText">
        Centrer la carte
      </div>
    </div>
  </div>
  <script src="openlayers/ol.js"></script>
  <script src="proj4js/dist/proj4-src.js"></script>
  <script src="jquery-3.1.1.min.js"></script>
  <script src="elasticsearch/elasticsearch.jquery.js"></script>
  <script>
  const BASE_URL = 'http://plf.poc.plf-sso.ppol.minint.fr/server/rest/services';
  const TILE_URL = BASE_URL + '/PP/FOND_PP_FINAL_512/MapServer';
  var URL_TEMPLATE = TILE_URL + '/tile/{z}/{y}/{x}';
  const LAMBERT93 = "+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";

  const SECOND_IN_MILLIS = 1000;
  const MINUTE_IN_MILLIS = 60*SECOND_IN_MILLIS;

  const REFRESH_TIME = 6 * SECOND_IN_MILLIS;

  const EARTH_RADIUS = 6371.01;

  const _E7 = Math.pow(10, 7);
  const RESOLUTIONS = [
    1322.9193125052918,
    529.1677250021168,
    264.5838625010584,
    185.20870375074085,
    119.06273812547626,
    92.60435187537043,
    66.1459656252646,
    39.687579375158755,
    26.458386250105836,
    13.229193125052918,
    6.614596562526459,
    2.6458386250105836,
    1.3229193125052918,
    0.7937515875031751,
    0.26458386250105836,
    0.13229193125052918,
    0.06614596562526459
  ]

  const INDEX = 'neo';
  const TYPE = 'tests'
  const _ID = 'neo_id';
  const _X = 'neo_x';
  const _Y = 'neo_y';
  const _ACCURACY = 'neo_accur';
  const _TIMESTAMP = 'neo_timestamp';

  var objectId = null, isGPSReady = false, id; // id = identifiantRadio saisi au debut
  var map;
  var watchID, lastDateQuery = Date.now(), lastDateUpdate = Date.now();
  var vectorSource;
  var allowXHR = true;

  // Saisie de l'identifiant Radio
  var client = new $.es.Client({
    hosts: 'http://plf.poc.plf-sso.ppol.minint.fr/es',
    // apiVersion: '2.4'
  });

  function login(type) {
    var form = document.getElementById('myForm');
    var idRadio = form.idRadio.value;
    if (idRadio != '0000' && idRadio != '') {
      id = type+idRadio;
      $('#idDiv').fadeOut(400);
      start();
    } else {
      showError('identifiant inconnu');
    }
  }

  // Lancement de l'application
  function start() {
    if (navigator.geolocation) {
      openNotification("Géolocalisation en cours, cliquez sur la carte pour indiquer votre position");
      initMap();
    } else {
      showError("Géolocalisation non supportée");
    }
  }

  // Initialisation de la map, du bouton 'centrer la carte'
  // + Gestion des events (singleclick et moveend)
  function initMap() {
    proj4.defs("EPSG:2154", "+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
    var point;

    client.search({
      index: INDEX,
      type: TYPE,
      body: {
        query : { match : {"neo_id" : id }}
      }
    }, function(error, response) {
      if (error != undefined) {
        console.error(error);
      } else if (response.hits.total == 0) {
        console.log(id+' non present dans la base');
        point = proj4('EPSG:4326', LAMBERT93, [2.362765, 48.841291]);
      } else {
        var feature = response.hits.hits[0];
        objectId = feature._id;
        console.log(objectId);
        point = [feature._source.neo_x, feature._source.neo_y];
      }
      sessionStorage.lastPosition = JSON.stringify(point);

      // Debut d'initialisation de l'objet map
      var EPSG_2154 = new ol.proj.Projection({
        code: 'EPSG:2154',
        extent: [503514.6000000015, 6683176.3999999985, 849432.8, 6997025],
        units: 'm'
      });

      // import de la projection de lambert93 dans openlayers
      ol.proj.addProjection(EPSG_2154);

      var tileg = new ol.tilegrid.TileGrid({
        origin: [-3.55975*_E7, 4.89531*_E7],
        resolutions: RESOLUTIONS,
        tileSize: 512
      });

      vectorSource = new ol.source.Vector({});

      var freepik = new ol.Attribution({
        html: '<div>Icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div>'
      });

      var plainicon = new ol.Attribution({
        html: '<div>Icons made by <a href="http://www.flaticon.com/authors/plainicon" title="Plainicon">Plainicon</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div>'
      });

      map = new ol.Map({
        target: 'map',
        layers: [
          new ol.layer.Tile({
            source: new ol.source.XYZ({
              attributions : [freepik, plainicon],
              tileUrlFunction: function(tileCoord, pixelRatio, projection) {
                var z = tileCoord[0];
                var x = tileCoord[1];
                var y = -tileCoord[2] - 1;
                return URL_TEMPLATE.replace('{z}', z.toString())
                .replace('{y}', y.toString())
                .replace('{x}', x.toString());
              },
              projection: EPSG_2154,
              tileGrid: tileg,
            })
          }),
          new ol.layer.Vector({
            source: vectorSource
          })
        ],
        view: new ol.View({
          center: point,
          projection: EPSG_2154,
          maxZoom:15,
          minZoom:2,
          zoom: 10
        })
      });
      // Fin d'initialisation de l'objet map

      // Gestion du click simple sur la carte pour l'initialisation manuelle
      // de sa position en attente du fix GPS
      var mapDiv = document.getElementById('map');
      var mousedown_x, mousedown_y, mouseup_x, mouseup_y;

      mapDiv.addEventListener('mousedown', function(event) {
        mousedown_x = event.clientX;
        mousedown_y = event.clientY;
      });

      mapDiv.addEventListener('mouseup', function(event) {
        mouseup_x = event.clientX;
        mouseup_y = event.clientY;

        if (mousedown_x == mouseup_x && mousedown_y == mouseup_y) {
          if(!isGPSReady) {
            var coordinates = map.getCoordinateFromPixel([mouseup_x, mouseup_y]);
            var mapPoint = {'x': coordinates[0], 'y': coordinates[1]};
            console.log(mapPoint);
            // x = lng, y = lat pour mapPoint_4326
            if (objectId == null) {
              addFeature(5, 203, 5, mapPoint);
            } else {
              updateFeature(5, 203, 5, mapPoint);
              lastDateUpdate = Date.now();
            }
            sessionStorage.lastPosition = JSON.stringify(coordinates);
          }
        }
      })

      // Gestion de l'evenement lorsque la vue de la carte change
      map.on('moveend', function(event) {
        if (!allowXHR) {allowXHR = true;}
        getFeaturesInMapExtent();
      });

      initControls();
      setInterval(getFeaturesInMapExtent, REFRESH_TIME);
      getLocation();
      // getFeaturesInMapExtent();
    });



  }

  // Initialisation du bouton permettant de recentrer la carte
  function initControls() {
    var centerUI = document.getElementById('centerUI');
    centerUI.addEventListener('click', recenterMap);
    document.getElementById('centerDiv').style.display = 'inline';
  }

  // Methode appelée a chaque modification de la vue de la map
  function recenterMap() {
    console.log("recenter");
    var lastPosition = JSON.parse(sessionStorage.lastPosition); // [x,y] en lambert93
    centerMap(lastPosition);
  }

  // Recentre la carte sur le point donné en argument
  function centerMap(center) {
    map.getView().animate({'center': center, zoom: 11, duration: 750});
  }

  // Initialisation du service de geolocalisation
  function getLocation() {
    watchID = navigator.geolocation.watchPosition(
      function(position) {
        if (!isGPSReady) {
          isGPSReady = true;
          // desactive le clic sur la carte pour indiquer manuellement sa position
          closeNotification();
        }
        updatePosition(position.coords);
      },
      function(error) {
        closeNotification();
        showError(error.message);
      },
      {maximumAge: 5000, enableHighAccuracy: true}
    );
  }

  // Met a jour la position sur la couche portal NEO si et seulement si la derniere
  // mise a jour n'a pas eu lieu dans les 5 dernieres secondes
  function updatePosition(coords) {
    var lat = coords.latitude, lng = coords.longitude, accuracy = coords.accuracy,
    alt = coords.altitude, heading = coords.heading, speed = coords.speed;
    // speed est en mph
    showNotification(lat+", "+lng+" - "+accuracy+"m"); // a supprimer
    if (Date.now() - lastDateUpdate > 5 * SECOND_IN_MILLIS)  {
      addFeature_wgs84(lat, lng, accuracy, heading, mphTokmph(speed));
      lastDateUpdate = Date.now();
    } else {
      console.log("too soon");
    }
  }

  // Utilise proj4js pour la conversion de la lat, lng vers la projection de lambert93
  // Sauvegarde de la dernière position dans sessionStorage
  // Envoi de la position au serveur (mise à jour ou création selon contexte)
  function addFeature_wgs84(lat, lng, accuracy, heading, speed) {
    var tmp = proj4('EPSG:4326', LAMBERT93, [lng, lat]);
    var lastPosition = JSON.stringify([tmp[0], tmp[1]]);
    sessionStorage.lastPosition = lastPosition;
    var mapPoint_2154 = {'x': tmp[0], 'y': tmp[1]};
    if (objectId == null) {
      addFeature(accuracy, heading, speed, mapPoint_2154);
    } else {
      updateFeature(accuracy, heading, speed, mapPoint_2154);
    }
  }

  function createDocument(id, x, y, accuracy, timestamp) {
    var doc = {};
    doc[_ID] = id;
    doc[_X] = x;
    doc[_Y] = y;
    doc[_ACCURACY] = accuracy;
    doc[_TIMESTAMP] = timestamp;
    return doc;
  }

  // Appel à l'API REST pour créer une nouvelle Feature
  function addFeature(accuracy, heading, speed, mapPoint) {
    var doc = createDocument(id, mapPoint.x, mapPoint.y, accuracy, Math.floor(Date.now() /1000));

    client.index({
      index: INDEX,
      type: TYPE,
      body: doc
    }, function (error, response) {
      if (error != undefined) {
        console.error(error);
      } else {
        objectId = response._id;
        if (!allowXHR) {
          allowXHR = true;
        }
        console.log(objectId);
      }
    });
  }

  // Appel à l'API REST pour mettre a jour une Feature existante
  function updateFeature(accuracy, heading, speed, mapPoint) {
    var doc = createDocument(id, mapPoint.x, mapPoint.y, accuracy, Math.floor(Date.now() /1000));

    client.index({
      index: INDEX,
      type: TYPE,
      id: objectId,
      body: doc
    }, function (error, response) {
      if (error != undefined) {
        console.error(error);
      } else {
        console.log(response);
        if (!allowXHR) {
          allowXHR = true;
        }
      }
    });
  }

  // permet de recuperer ma feature (et donc objectID) a partir de mon identifiant radio
  // si et seulement si j'existe deja
  // deplacée dans la methode initMap car il y a du code a executer dans le callback
  // function getMyFeature() {
  //   client.search({
  //     index: INDEX,
  //     type: TYPE,
  //     body: {
  //       query : { match : {"neo_id" : id }}
  //     }
  //   }, function(error, response) {
  //     if (error != undefined) {
  //       console.error(error);
  //     } else if (response.hits.total == 0) {
  //       console.log(id+' non present dans la base');
  //     } else {
  //       console.log(response.hits.hits[0]);
  //       objectId = response.hits.hits[0]._id;
  //     }
  //   });
  // }

  // Permet d'obtenir les limites(extent) de la carte en projection de lambert93
  // dans le bon format pour effectuer une requete REST /query
  function getMapExtent() {
    var e = map.getView().calculateExtent(map.getSize());
    var extent = {
      'xmin': e[0],
      'ymin': e[1],
      'xmax': e[2],
      'ymax': e[3],
    }
    return extent;
  }

  // Permet de recuperer uniquement les features qui seront visibles sur la carte
  function getFeaturesInMapExtent() {
    if (Date.now() - lastDateQuery > 5 * SECOND_IN_MILLIS || allowXHR) {
      var geometry = getMapExtent();
      client.search({
        index: INDEX,
        body: {
          query : {
            "bool" : {
              "must" : {
                "range" : {"neo_x": { "gte" : geometry.xmin, "lte" : geometry.xmax } },
                "range" : {"neo_y": { "gte" : geometry.ymin, "lte" : geometry.ymax } }
              }
            }
          }
        },
        timeout: '5s'
      }, function(error, response) {
        if (error != undefined) {
          console.error(error);
        } else {
          console.log(JSON.stringify(response.hits.hits));
          refresh(response.hits.hits);
          // do something with results
          lastDateQuery = Date.now();
          if (allowXHR) {
            allowXHR = false;
          }
        }
      });
    } else {
      console.log('TOO SOON - getFeaturesInMapExtent');
    }
  }

  // Permet de mettre a jour l'affichage des features
  function refresh(hits) {
    var i, length = hits.length;
    if (length == 0) return;
    console.log('refresh');
    vectorSource.clear();
    for (i = 0; i < length ; i++) {
      var feature = hits[i];
      var timestamp = feature._source.neo_timestamp * 1000;
      var delta = Date.now() - timestamp;
      if (delta > 60*6 * MINUTE_IN_MILLIS) {
        continue;
      }
      if (feature._source.neo_accur > 24) {
        addCircle(feature, delta);
        addMarker(feature, delta);
      } else {
        addMarker(feature, delta);
      }
    }
  }

  // Permet de recuperer le prefixe de l'image .png a partir du 'type'
  function getType(type) {
    switch (type) {
      case 'b_':
      return 'bicycle';
      break;
      case 'm_':
      return 'bike';
      break;
      case 'c_':
      return 'car';
      break;
      case 'p_':
      return 'policeman';
      break;
      case 'o_':
      return 'office';
      break;
      case 'f_':
      return 'boat';
      break;
      default:
      console.error("getType : Je ne dois pas passer ici "+type);
    }
  }

  // Permet de recuperer la couleur de l'image .png a partir d'une couleur
  function getColor(color) {
    switch (color) {
      case 'red':
      return 'R';
      break;
      case 'blue':
      return 'B';
      break;
      case 'green':
      return 'G';
      break;
      default:
      console.error("getColor : je ne dois pas passer ici "+color);
    }
  }

  // Permet de recuperer un code couleur a partir d'une couleur('red'|'green'|'blue')
  function getColorRGB(color) {
    switch (color) {
      case 'red':
      return '#F00';
      break;
      case 'blue':
      return '#00F';
      break;
      case 'green':
      return '#2EC854';
      break;
      default:
      console.error("getColorRGB : je ne dois pas passer ici "+color);
    }
  }

  // Permet de recuperer une couleur rgba a partir d'une couleur
  function getColorRGBA(color) {
    switch (color) {
      case 'red':
      return 'rgba(255, 0, 0, 0.1)';
      break;
      case 'blue':
      return 'rgba(0, 0, 255, 0.1)';
      break;
      case 'green':
      return 'rgba(0, 255, 0, 0.1)';
      break;
      default:
      console.error("getColorRGBA : je ne dois pas passer ici "+color);
    }
  }

  // Fonction de sytle d'un cercle d'incertitude
  // Permet d'obtenir la bonne couleur d'un cercle d'incertitude
  function circleStyle() {
    return [
      new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: this.get('color'),
          width: 1
        }),
        fill: new ol.style.Fill({
          color: getColorRGBA(this.get('color'))
        })
      })
    ];
  }

  // Fonction de style d'un marker
  // Permet d'obtenir la bonne icone et couleur d'une feature
  function markerStyle() {
    var zoom = map.getView().getZoom();
    var color = this.get('color');
    var suffixe = getColor(color);
    var type = getType(this.get('type'));

    return [
      new ol.style.Style({
        text: new ol.style.Text({
          font: '14px Calibri',
          fill: new ol.style.Fill({ color: getColorRGB(color) }),
          offsetY: -15,
          stroke: new ol.style.Stroke({
            color: '#fff', width: 2
          }),
          text: zoom > 8 ? this.get('neo_id') : '', // revoir les param de zoom
        }),
        image: new ol.style.Icon(({
          src: zoom < 5 ? 'images/dot'+suffixe+'.png':
          zoom < 9 ? 'images/'+type+suffixe+'_16.png' :
          'images/'+type+suffixe+'.png'
        }))
      })
    ];
  }

  // Permet d'ajouter un cercle d'incertitude sur la map a partir d'une feature
  // delta : temps depuis la derniere mise a jour de la feature
  function addCircle(feature, delta) {
    var neo_id = feature._source.neo_id;
    var radius = feature._source.neo_accur;
    var x = feature._source.neo_x;
    var y = feature._source.neo_y;
    var circle = new ol.geom.Circle([x, y], radius);
    var feat = new ol.Feature({geometry: circle});
    if (neo_id == id) {
      feat.set('color', 'red');
    } else {
      if (delta > 5 * MINUTE_IN_MILLIS) {
        feat.set('color', 'blue');
      } else {
        feat.set('color', 'green');
      }
    }
    feat.setStyle(circleStyle);
    vectorSource.addFeature(feat);
  }


  // permet d'ajouter un marker sur la map a partir d'une feature
  // delta : temps depuis la derniere mise a jour de la feature
  function addMarker(feature, delta) {
    var neo_id = feature._source.neo_id;
    var x = feature._source.neo_x;
    var y = feature._source.neo_y;
    var point = new ol.geom.Point([x, y]);
    var feat = new ol.Feature({geometry: point});
    if (neo_id == id) {
      feat.set('color', 'red');
    } else {
      if (delta > 5 * MINUTE_IN_MILLIS) {
        feat.set('color', 'blue');
      } else {
        feat.set('color', 'green');
      }
    }
    feat.set('neo_id', neo_id.slice(2));
    feat.set('type', neo_id.substring(0,2));
    feat.setStyle(markerStyle);
    vectorSource.addFeature(feat);
  }


  function degreeToRadian(angle) {
    return angle * Math.PI / 180;
  }

  function radianToDegree(angle) {
    return angle * 180 / Math.PI;
  }

  function mphTokmph(speed) {
    return speed * 1.609344;
  }

  // Permet d'extrapoler une nouvelle position a partir des coordonness GPS,
  // du cap, de la vitesse, et du temps ecoule depuis la derniere maj
  // lat,lng in WGS48, speed in km/h, heading in degrees, time in seconds
  function getNext(lat, lng, speed, heading, time) {
    console.log('in : '+lat+','+lng);
    console.log('speed: '+speed);
    console.log('heading: '+heading);
    console.log('time: '+time);
    var kmDistance = speed * (time / 3600);

    var headingRad = degreeToRadian(heading);

    var distRatio = kmDistance / EARTH_RADIUS;
    var distRatioSine = Math.sin(distRatio);
    var distRatioCosine = Math.cos(distRatio);

    var startLatRad = degreeToRadian(lat);
    var startLngRad = degreeToRadian(lng);

    var startLatCos = Math.cos(startLatRad);
    var startLatSin = Math.sin(startLatRad);

    var endLatRads = Math.asin((startLatSin * distRatioCosine) + (startLatCos * distRatioSine * Math.cos(headingRad)));

    var endLonRads = startLngRad
    + Math.atan2(Math.sin(headingRad) * distRatioSine * startLatCos,
    distRatioCosine - startLatSin * Math.sin(endLatRads));

    var newLat = radianToDegree(endLatRads);
    var newLng = radianToDegree(endLonRads);

    var obj = [newLng, newLat]
    console.log(obj);
    return obj;
  }

  // Permet d'extrapoler localement les nouvelles positions des features visibles
  // Utilisé en cas de coupure réseau pour le moment
  function calculateNextPositions() {
    var now = Math.floor(Date.now()/1000);
    var length = localFeatures.length;
    var i;
    for (i = 0; i < length; i++) {
      var feature = localFeatures[i];
      var then = feature.attributes.neo_timestamp;
      var geometry = feature.geometry;
      var speed = feature.attributes.neo_speed;
      var heading = feature.attributes.neo_heading;
      var lat = feature.attributes.neo_lat;
      var lng = feature.attributes.neo_lng;
      var newPosition = getNext(lat, lng, speed, heading, now - then);
      var tmp = proj4('EPSG:4326', LAMBERT93, newPosition)
      localFeatures[i].geometry.x = tmp[0];
      localFeatures[i].geometry.y = tmp[1];
    }
    refresh(localFeatures);
  }

  // MESSAGES DE NOTIFICATION ET D'ERREUR
  function showNotification(message) {
    document.getElementById('notification').innerHTML = message;
    $('#notification').fadeIn(400).delay(1500).fadeOut(400);
  }

  function openNotification(message) {
    document.getElementById('notification').innerHTML = message;
    $('#notification').fadeIn(500);
  }

  function closeNotification() {
    $('#notification').fadeOut(200);
  }

  function showError(message) {
    document.getElementById('error').innerHTML = message;
    $('#error').fadeIn(400).delay(2000).fadeOut(400);
  }

  </script>
</body>
</html>
